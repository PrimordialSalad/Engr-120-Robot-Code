#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    IRsensorDown,   sensorReflection)
#pragma config(Sensor, in2,    IRsensorLeft,   sensorReflection)
#pragma config(Sensor, in3,    IRsensorFront,  sensorReflection)
#pragma config(Sensor, in4,    IRsensorRight,  sensorReflection)
#pragma config(Sensor, in5,    IRsensorDown,   sensorNone)
#pragma config(Sensor, dgtl2,  LeftFrontButton, sensorTouch)
#pragma config(Sensor, dgtl3,  RightFrontButton, sensorTouch)
#pragma config(Sensor, dgtl4,  LeftBackButton, sensorTouch)
#pragma config(Sensor, dgtl5,  RightBackButton, sensorTouch)
#pragma config(Sensor, dgtl6,  StateLED,       sensorDigitalOut)
#pragma config(Sensor, dgtl11, SonarSensorIN,  sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           RightSideDrive, tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           Arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          LeftSideDrive, tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////Header Comment/////////////////////////////////////////////////////////

/*	I removed the function calls to monitor light front, left, down, and right because I didn't write those functions 
	and I was not sure if I would have been allowed to submit them to git.  Therefore they were removed.  
	Everything else was my own creation.  The robot was made using VEX Robot C which is why it looks similar to C 
	but there are a few extra keywords.  This code still has issues, if it is looking for the target and it loses it
	will not find it again, for whatever reason.  It also gets slightly confused if there is copious amounts of sunlight, 
	as it might mess up the IR phototransistor readings but most of the time it works.
*/

////////////////////////////////////////////////////End of Header Comment////////////////////////////////////////////////////

//Right going 60 and left is going 100 will help the robot go straight.
//minLevelFrontSensor < SensorValue[IRsensorFront] Old if condition, in case the new one breaks.
//Revert to this one if it does.

int currentTurningDirection = 0;  //0 for right, 1 for left.

const int liftMotorSpeed = 30;
const int light_threshold = 1600; //The threshold for the light detection.  Used to be 1025

bool test1ButtonPushed = false; //These track if the tests should be started or not.
bool found = false; // This tracks if the beacon has been found.

bool beaconVisibleFront; //The true or false indicator for if the beacon can be seen from the front.
bool beaconVisibleLeft; //The true or false indicator for if the beacon can be seen from the left.
bool beaconVisibleRight; //The true or false indicator for if the beacon can be seen from the right.
bool beaconVisibleDown; //The true or false indicator for if the beacon can be seen from the back.


int minLevelFrontSensor = 4096;	// Minimum light level seen by IR sensor front
int maxLevelFrontSensor = 0;			// Maximum light level seen by IR sensor front

int minLevelRightSensor = 4096;	// Minimum light level seen by IR sensor front
int maxLevelRightSensor = 0;			// Maximum light level seen by IR sensor front

int minLevelLeftSensor = 4096;	// Minimum light level seen by IR sensor front
int maxLevelLeftSensor = 0;			// Maximum light level seen by IR sensor front

int minLevelBackSensor = 4096;	// Minimum light level seen by IR sensor front
int maxLevelBackSensor = 0;			// Maximum light level seen by IR sensor front

int globalMin = 4096; //This keeps track of the largest min that was read from the front sensor.



typedef enum t_HuntState //The state machine for which action the robot is performing.
{
	UNKNOWN = 0,
	BACK_TO_FRONT,
	RIGHT_TO_FRONT,
	LEFT_TO_FRONT,
	BACK_TO_RIGHT,
	CENTER_FROM_LEFT,
	CENTRE_FROM_RIGHT,
	CENTRED
} HuntState;

HuntState robotState = UNKNOWN; //The variable for the state machine.  This is used to control the switch statement.
HuntState lastState = UNKNOWN; //This records the last known state.  So the robot knows the direction it is turning.

int returnDistanceFromFront()
{
	return SensorValue(SonarSensorIN); //Return the value in cm.
}

int detectWallCollision() //This is used to detect whether or not the walls were contacted and by what sensors.
{
	int result = 0;

	if(returnDistanceFromFront() < 22)
	{
		result += 1;
	}

	if(SensorValue(RightFrontButton) == 1)
	{
		result += 1;
	}

	if(SensorValue(LeftFrontButton) == 1)
	{
		result += 1;
	}

	if(SensorValue(RightBackButton) == 1)
	{
		result += 1;
	}

	if(SensorValue(LeftBackButton) == 1)
	{
		result += 1;
	}

	return result; //This result will be the sum of the number of sensors that have contacted with the wall.
}

int detectWallCollisionWithoutSonar()  //This is a duplicate of the above function, just without the check to the sonar.
{
	int result = 0;
	if(SensorValue(RightFrontButton) == 1)
	{
		result += 1;
	}

	if(SensorValue(LeftFrontButton) == 1)
	{
		result += 1;
	}

	if(SensorValue(RightBackButton) == 1)
	{
		result += 1;
	}

	if(SensorValue(LeftBackButton) == 1)
	{
		result += 1;
	}

	return result; //This result will be the sum of the number of sensors that have contacted with the wall.
}

void monitorTest1Button() //This monitors the button input for test 1.
{
	if(SensorValue[LeftFrontButton] == 1)
	{
		test1ButtonPushed = true;
	}
}

//This checks whether or not the robot is at the correct distance for attachment to the target object.  Signals true or false.
bool correctDistanceForAttachment() 
{
	bool result = true;

	if(returnDistanceFromFront() > 20 || returnDistanceFromFront() < 13)
	{
		result = false;
	}

	return result;
}

void stopMoving() //This is just a function to stop the robot drive motors.
{
	motor[port1] = 0;
	motor[port10] = 0;
}

void moveStraightForward() // This is a function to move the robot straight forward.
{
		motor[port1] = 30;
		motor[port10] = 50;
}

void moveStraightForward(int timeToMove) // This is a function to move the robot forward for an alloted time.
{
	motor[port1] = 40;
	motor[port10] = 60;
	wait1Msec(timeToMove);
	stopMoving();
}

void moveStraightBackward(int timeToMove) //This is a function to move the robot straight backward for an alloted time.
{
	motor[port1] = -40;
	motor[port10] = -60;
	wait1Msec(timeToMove);
	stopMoving();
}

void moveStraightBackward() //This is a function to move the robot straight backward.
{
	motor[port1] = -40;
	motor[port10] = -60;
}

void findGlobalMin() //This checks to see if the current sensor reading is the lowest min that has been seen.
{
	if(SensorValue[IRsensorFront] < globalMin)
	{
		globalMin = SensorValue[IRsensorFront];
	}
}

//This function checks to see what sensors are being activated by the wall and acts accordingly.
void fixWallCollisionWithoutSonar()
{
	stopMoving();
	if((SensorValue(RightFrontButton) == 1) || (SensorValue(LeftFrontButton) == 1))
	{
		moveStraightBackward(1000);
	}
	else if((SensorValue(RightBackButton) == 1) || (SensorValue(LeftBackButton) == 1))
	{
		moveStraightForward(1000);
	}
}

bool moveForwardOnceFound() //This is a function that moves the robot forward once the beacon is found.
{
	bool result = true;

	while(!correctDistanceForAttachment()) //Continue to drive forward until at the right distance.
	{

		if(!monitorLightFront() || detectWallCollisionWithoutSonar() > 0)
		{
// If the beacon is still visible out the front but robot is against a wall.  Will remedy the situation accordingly.
			if(detectWallCollisionWithoutSonar() > 0)
			{
				fixWallCollisionWithoutSonar();
			}

			else //else set result to false and refind the beacon.
			{
				result = false;
				break;
			}
		}
		//Go until this distance.  Perfect distance for connection.
		else if(returnDistanceFromFront() > 20 || returnDistanceFromFront() == -1)
		{
			moveStraightForward();
		}
		else if(returnDistanceFromFront() < 13) //To close back up until further from the distance.
		{
			moveStraightBackward(500);
		}
	}
	stopMoving();

	return result;
}

int returnAverageMin() //Returns the average min of the other 3 phototransistors.
{
	return ((minLevelBackSensor + minLevelRightSensor + minLevelLeftSensor) / 3);
}

void detachmentMechanism() // This is a function that executes the robot's detachment mechanism.
{
	motor[port9] = -liftMotorSpeed;
	wait1Msec(1500);
	motor[port9] = liftMotorSpeed;
	wait1Msec(1100);
	motor[port9] = 0;
}

void backupAndTurn() //Used for backing away from the beacon after connection.  There was no turn action implemented.
{
	moveStraightBackward(1000);
}

void fixWallCollision() //This is the function that checks to see which sensors are being triggered and remedy the situation.
{
	stopMoving();

	if((returnDistanceFromFront() < 22) || (SensorValue(RightFrontButton) == 1) || (SensorValue(RightBackButton) == 1))
	{
		moveStraightBackward(1000);
	}

	if((SensorValue(RightBackButton) == 1) || (SensorValue(LeftBackButton) == 1))
	{
		moveStraightForward(1000);
	}
}

void huntBeacon() //This function is run to allow the robot to locate the target object.
{
//This and the rest of the assignment statements are to monitor detection of the beacon at the 4 cardinal positions.
	beaconVisibleFront = monitorLightFront();
	beaconVisibleLeft = monitorLightLeft();
	beaconVisibleRight = monitorLightRight();
	beaconVisibleDown = monitorLightDown();
	findGlobalMin(); //This updates the global min on every pass through this function.
	int wallCollision = detectWallCollision(); //Monitors if a wall collision has occured.


	switch(robotState) //This is the state machine for which action the robot is performing.
	{

	case CENTRE_FROM_RIGHT: //This is if the robot is tweaking forward alignment having just turned from the right.

		if(wallCollision > 0) //Checks for any wall collisions.
		{
			fixWallCollision();
		}
			
//Checks if the min level of the front sensor is below the accepted values.
		if(minLevelFrontSensor < returnAverageMin()) 
		{
//This checks to see if the sensor is reading things that are higher than the global min.
			if(globalMin < minLevelFrontSensor)
			{
//While the sensor is greater than the global min plus a deadband, turn towards it.
				while(SensorValue[IRsensorFront] > (globalMin + 40))
				{
					currentTurningDirection = 1;
					motor[port1] = -40;
					motor[port10] = 70;
				}

				stopMoving();
				found = true; //Sets the beacon found variable to true.
				robotState = CENTRED; //Transfers to the state CENTRED to commence driving operation.
			}

			else
			{
				currentTurningDirection = 0; //If the sensor level wasn't low enough, keep turning right.
				motor[port1] = 40;
				motor[port10] = -70;
			}
		}

		break;

	case CENTER_FROM_LEFT: //This is if the robot is tweaking forward alignment having just turned from the left.

		if(wallCollision > 0) //Checks for any wall collisions.
		{
			fixWallCollision();
		}
//Checks to see if the min level of the front sensor is below the accepted values.
		if(minLevelFrontSensor < returnAverageMin())
		{
//If this statement is true, the robot has turned past the beacon and needs to turn back.
			if(globalMin < minLevelFrontSensor)
			{
//While the sensor is greater than the global min plus some deadband, turn towards it.
				while(SensorValue[IRsensorFront] > (globalMin + 40))
				{
					currentTurningDirection = 0;
					motor[port1] = 40;
					motor[port10] = -70;
				}

				stopMoving();
				found = true; //Sets the beacon found variable to true.
				robotState = CENTRED; //Transfers to the state CENTRED to commence driving operation.
			}

			else
			{
				currentTurningDirection = 0; // If the sensor wasn't low enough, keep turning.
				motor[port1] = -40;
				motor[port10] = 70;
			}
		}

		break;
			
//This is if the robot is turning from the back sensor being detected to the right sensor being detected.
	case BACK_TO_RIGHT:

		if(wallCollision > 0) //Checks for any wall collisions.
		{
			fixWallCollision();
		}

		currentTurningDirection = 0; //Starts the robot turning to the right
		motor[port1] = 40;
		motor[port10] = -70;

		if(beaconVisibleRight) //If the robot detects the beacon at the front, then it switches states.
		{
			stopMoving();
			lastState = robotState;
			robotState = RIGHT_TO_FRONT;
		}

		break;
			
//This is if the robot is turning from the left sensor being detected to the front sensor being detected.
	case LEFT_TO_FRONT:

		if(wallCollision > 0) //Checks for any wall collisions.
		{
			fixWallCollision();
		}

		currentTurningDirection = 1; //Starts the robot turning left.
		motor[port1] = -40;
		motor[port10] = 70;

		if(beaconVisibleFront) //If the beacon is visible on the front sensor, then it switches states.
		{
			stopMoving();
			lastState = robotState;
			robotState = CENTER_FROM_LEFT;
		}

		break;
			
//This is if the robot is turning from the right sensor being detected to the front sensor being detected.
	case RIGHT_TO_FRONT:

		if(wallCollision > 0) //Checks for any wall collisions.
		{
			fixWallCollision();
		}

		currentTurningDirection = 0; //Starts the robot turning right.
		motor[port1] = 40;
		motor[port10] = -70;

		if(beaconVisibleFront) //If the beacon is visible on the front sensor, the it switches states.
		{
			stopMoving();
			lastState = robotState;
			robotState = CENTRE_FROM_RIGHT;
		}

		break;
			
//This is the default case, it will turn right if it doesn't have any detection or if the robot senses it at the back.
	case UNKNOWN:
	case BACK_TO_FRONT:

		if(wallCollision > 0) //Checks for wall collisions.
		{
			fixWallCollision();
		}

		currentTurningDirection = 0; //Starts the robot turning right.
		motor[port1] = 40;
		motor[port10] = -70;

		if(beaconVisibleRight) //If the beacon is visisble on the right sensor, then switch states.
		{
			stopMoving();
			lastState = robotState;
			robotState = RIGHT_TO_FRONT;
		}

		else if(beaconVisibleFront) //If the beacon is visible on the front sensor, then switch states.
		{
			stopMoving();
			lastState = robotState;
			robotState = CENTRE_FROM_RIGHT;
		}

		break;
			
//This case breaks out of the switch statement and in main calls the functions to commence the driving operation.
	case CENTRED:
	default:
	}

}

task main() //The main task where all the other functions get called.
{
	SensorValue[StateLED] = 0; //Sets the LED to off for the beginning of the code's execution.


	while(true)
	{
//Checks to see if the button is pushed, just so it doesn't have to keep checking if it has been.
		if(!test1ButtonPushed)
		{
			monitorTest1Button(); //This monitors the button for starting test 1.
		}

		bool canConnect = false;

		if(test1ButtonPushed) //Checks to see if it should start the test.
		{
			if(!found) //If the beacon has not been found, hunt for the beacon.
			{
				huntBeacon();
			}
			else //If the beacon has been found, then travel towards it.
			{

				stopMoving();
				canConnect = moveForwardOnceFound(); //Makes sure it can connect.

				if(canConnect) //If it can connect then commence the detachment mechanism.
				{
					detachmentMechanism(); //The function which is responsible for detaching the cable.
					backupAndTurn(); //Backs up to move away from the target object.
					SensorValue[StateLED] = 1; //Turns on the LED to symbolize task completion.
					test1ButtonPushed = false; //Resets the button pushes.
					found = false; //Resets if the beacon has been found.
				}

				else //If it can't connect, then that would mean that it is not aligned anymore.
				{
					currentTurningDirection = 0; //Set the current turning direction.
					robotState = CENTER_FROM_LEFT; //Set the robot state to something other than centered.
					found = false; //Set the beacon has been found to false.
					continue; //Jump to the next iteration of the while loop.
				}
			}
		}
	}
}
